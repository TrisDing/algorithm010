Learning Notes Week 08
======================

Primitives
----------

Twos Complement
```py
-8 4 2 1
[1 0 0 0]  -8
[1 0 0 1]  -7
[1 0 1 0]  -6
[1 0 1 1]  -5
[1 1 0 0]  -4
[1 1 0 1]  -3
[1 1 1 0]  -2
[1 1 1 1]  -1
[0 0 0 0]   0
[0 0 0 1]   1
[0 0 1 0]   2
[0 0 1 1]   3
[0 1 0 0]   4
[0 1 0 1]   5
[0 1 1 0]   6
[0 1 1 1]   7
```

How to Convert Negative Number
```py
        [0 1 0 1]  5
Invert  [1 0 1 0]
Plus 1  [1 0 1 0] -5

        [0 0 0 1 0 0 0 0]  16
Invert  [1 1 1 0 1 1 1 1]
Plus 1  [1 1 1 1 0 0 0 0] -16
```

Bit-wise operators
```py
6 & 4       # 0110 & 0100 = 0100 (4)                     AND
1 | 2       # 0001 | 0010 = 0011 (3)                     OR
15 ^ 1      # 00001111 ^ 00000001 = 00001110 (14)        XOR
8 >> 1      # 00001000 >> 1 = 00000100 (4)               x >> y = x // 2^y
1 << 10     # 000000000001 << 10 = 010000000000 (1024)   x << y = x * 2^y
-16 >> 2    # 11110000 >> 2 = 11111100 (-4)              negative right shifting
-16 << 2    # 11110000 << 2 = 11000000 (-64)             negative left shifting
~0          # ~0000 = 1111 (-1)                          ~x = -x - 1
```

Bit Operation Tricks
```py
x & 1 == 1        # Odd number, same as x % 2 == 1
x & 1 == 0        # Even number, same as x % 2 == 0
x >> 1            # Same as x / 2
x & 1             # Extract the last bit
(x >> k) & 1      # Extract the Kth bit
x |= 1            # Set the last bit
x |= (1 << k)     # Set the Kth bit
x ^= 1            # Flip the last bit
x ^= (1 << k)     # Flip the Kth bit
x & (x - 1)       # Drop the lowest set bit of x
x & ~(x - 1)      # Extract the lowest set bit of x
x & (-x)          # Keep the lowest set bit and sets all the other bits to 0
```

Leetcode Problems
- [191. Number of 1 Bits](https://leetcode.com/problems/number-of-1-bits/)
- [231. Power of Two](https://leetcode.com/problems/power-of-two/)
- [190. Reverse Bits](https://leetcode.com/problems/reverse-bits/)
- [338. Counting Bits](https://leetcode.com/problems/counting-bits/)

Bloom Filter
------------

> A Bloom filter is a space-efficient probabilistic data structure that is used to test whether an element is a member of a set. The price for efficiency is that it is probabilistic in nature that means, there might be some False Positive results.

```
INITIAL BITS
0 0 0 0 0 0 0 0 0 0

INSERT X {0, 3, 7}
(1) 0 0 (1) 0 0 0 (1) 0 0

INSERT Y {2, 3, 4}
1 0 (1) (1) (1) 0 0 1 0 0

SEARCH Z {1, 4, 7}
1 (0) 1 1 (1) 0 0 (1) 0 0 <== Probably Present

SEARCH W {1, 5, 6}
1 (0) 1 1 1 (0) (0) 1 0 0 <== Definitely NOT Present
```

Properties
- Unlike a standard hash table, a Bloom filter of a fixed size can represent a set with an arbitrarily large number of elements.
- Bloom filters never generate false negative result
- Adding an element never fails. However, the false positive rate increases steadily as elements are added until all bits in the filter are set to 1, at which point all queries yield a positive result.
- Deleting elements from filter is not possible because, if we delete a single element by clearing bits at indices generated by k hash functions, it might cause deletion of few other elements.

LRU Cache
---------

> Discards the least recently used items first. This algorithm requires keeping track of what was used when, which is expensive if one wants to make sure the algorithm always discards the least recently used item.

```
      A    B    C    D    E    F    C    G
--------------------------------------------
[ ]  [A]  [B]  [C]  [D]  [E]  [F]  [C]  [G]
[ ]  [ ]  [A]  [B]  [C]  [D]  [E]  [F]  [C]
[ ]  [ ]  [ ]  [A]  [B]  [C]  [D]  [E]  [F]
[ ]  [ ]  [ ]  [ ]  [A]  [B]  [C]  [D]  [E]
[ ]  [ ]  [ ]  [ ]  [ ]  [A]  [B]  [B]  [D]
--------------------------------------------
                              [A]       [B]
```

Properties
- Native Implementation: Hash Table + Doubly LinkedList
- Python API Implementation: `collections.OrderedDict()`
- O(1) lookup
- O(1) update

Leetcode Problems
- [146. LRU Cache](https://leetcode.com/problems/lru-cache/)

Sorting
----------

Sorting Algorithms
- Comparison Sorts
  - Simple Sorts
    - Bubble Sort
    - Selection Sort
    - Insertion Sort
  - Efficient Sorts
    - Merge Sort
    - Quick Sort
    - Heap Sort
- Non-comparison Sorts
  - Distribution Sorts
    - Counting Sort
    - Bucket Sort
    - Radix Sort

| Sorting        | Average   | Worst     | Best      | Space     | Stability |
| :------------- | :-------- | :-------- | :-------- | :-------- | :-------- |
| Bubble Sort    | O(N^2)    | O(N^2)    | O(N)      | O(1)      | YES       |
| Selection Sort | O(N^2)    | O(N^2)    | O(N^2)    | O(1)      | NO        |
| Insertion Sort | O(N^2)    | O(N^2)    | O(N)      | O(1)      | YES       |
| Merge Sort     | O(N*logN) | O(N*logN) | O(N*logN) | O(N)      | YES       |
| Quick Sort     | O(N*logN) | O(N^2)    | O(N*logN) | O(N*logN) | NO        |
| Heap Sort      | O(N*logN) | O(N*logN) | O(N*logN) | O(1)      | YES       |
| Counting Sort  | O(N+k)    | O(N+k)    | O(N+k)    | O(N+k)    | YES       |
| Bucket Sort    | O(N+k)    | O(N^2)    | O(N)      | O(N+k)    | YES       |
| Radix Sort     | O(N*k)    | O(N*k)    | O(N*k)    | O(N+k)    | YES       |